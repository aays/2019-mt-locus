# clean_lastz_output.R
#
# takes in a tsv generated by lastz
# via the --format=general option
# (default columns) and removes
# any instances where a target region
# has multiple instances in a query region
#
# -> these are resolved by selecting the
# alignment that has the highest x-drop score
#
# usage Rscript clean_lastz_output.R [infile] [outfile]

library(readr)
library(dplyr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(magrittr, warn.conflicts = FALSE)
library(optparse)

option_list <- list(
    make_option(c("-f", "--file"), type = "character", default = NULL, 
              help = "Input lastz dataset", metavar = "character"),
    make_option(c("-o", "--outfile"), type = "character", default = NULL, 
              help= "Output file name", metavar = "character")
) 

opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)

d <- read_tsv(opt$file)

colnames(d)[1] <- 'score' # prevent formatting errors

d %<>% 
    group_by(zstart1) %>%
    mutate(max_score = max(score)) %>%
    filter(score == max_score) %>%
    select(-max_score) %>%
    mutate(match_count = n()) %>%
    mutate(first = min(zstart2)) %>% # identical matches
    filter(zstart2 == first) %>%
    select(-first)
    
# assert no double matches left
test <- d %>%
    select(zstart1) %>%
    unlist() %>% unique()

stopifnot(length(d) == 1)

write_csv(d, file = opt$out, sep = '\t', row.names = FALSE)



