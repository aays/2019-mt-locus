# clean_lastz_output.R
#
# takes in a tsv generated by lastz
# via the --format=general option
# (default columns) and removes
# any instances where a target region
# has multiple instances in a query region
#
# these are resolved by selecting the
# alignment that has the highest x-drop score
#
# this script will also correct for overlapping
# alignments by modifying the end1 coordinate -
# although this doesn't impact the aligned regions,
# it may mean the other stats (identity, coverage, etc)
# are not completely accurate in the outfile.
# I'm sticking with this since we aren't using any of
# those metrics to filter for this analysis in the first
# place.
# 
# usage Rscript clean_lastz_output.R [infile] [outfile]

library(readr)
library(dplyr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(magrittr, warn.conflicts = FALSE)
library(optparse)

option_list <- list(
    make_option(c("-f", "--file"), type = "character", default = NULL, 
              help = "Input lastz dataset", metavar = "character"),
    make_option(c("-o", "--outfile"), type = "character", default = NULL, 
              help= "Output file name", metavar = "character")
) 

opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)

d <- read_tsv(opt$file, col_types = cols())

# to prevent formatting errors
colnames(d)[1] <- 'score'

# remove duplicates
d %<>% 
    group_by(zstart1) %>%
    mutate(max_score = max(score)) %>%
    filter(score == max_score) %>%
    select(-max_score) %>%
    mutate(first = min(zstart2)) %>% # identical matches
    filter(zstart2 == first) %>%
    select(-first) %>%
    ungroup()
    
# prevent overlapping alignments
d %<>%
    arrange(zstart1) %>%
    mutate(next_start = lead(zstart1)) %>%
    mutate(in_interval = ifelse(next_start < end1, 1, 0)) %>%
    mutate(end1 = ifelse(in_interval == 1, next_start, end1)) %>%
    select(-next_start, -in_interval)

# assert no double matches left
test <- d %>%
    group_by(zstart1) %>%
    mutate(match_count = n()) %>%
    ungroup() %>%
    select(match_count) %>%
    unlist() %>% unique()

stopifnot(length(test) == 1)

write_tsv(d, path = opt$out)

message('\nFile successfully cleaned.')
message(paste('Output written to', opt$out))
message('Good job!')

