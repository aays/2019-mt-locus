# clean_lastz_output.R
#
# takes in a tsv generated by lastz
# via the --format=general option
# (default columns) and removes
# any instances where a target region
# has multiple instances in a query region
#
# these are resolved by selecting the
# alignment that has the highest x-drop score
# 
# usage Rscript clean_lastz_output.R [infile] [outfile]

library(readr)
library(dplyr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(magrittr, warn.conflicts = FALSE)
library(optparse)

option_list <- list(
    make_option(c("-f", "--file"), type = "character", default = NULL, 
              help = "Input lastz dataset", metavar = "character"),
    make_option(c("-o", "--outfile"), type = "character", default = NULL, 
              help= "Output file name", metavar = "character")
) 

opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)

d <- read_tsv(opt$file, col_types = cols())

# to prevent formatting errors
colnames(d)[1] <- 'score'

# remove duplicates
d %<>% 
    group_by(zstart1) %>%
    filter(score == max(score)) %>%
    filter(zstart2 == min(zstart2)) %>%
    ungroup()

# assert no double matches left
test <- d %>%
    group_by(zstart1) %>%
    mutate(match_count = n()) %>%
    ungroup() %>%
    select(match_count) %>%
    unlist() %>% unique()

stopifnot(length(test) == 1)

write_tsv(d, path = opt$out)

message('\nFile successfully cleaned.')
message(paste('Output written to', opt$out))
message('Good job!')

